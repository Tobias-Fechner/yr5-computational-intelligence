from random import randint, random, uniform
import numpy as np
import logging
logging.basicConfig()
logging.getLogger().setLevel(logging.INFO)

def individual(length, min, max):
    'Create a member of the population.'
    return [ randint(min,max) for x in range(length) ]

def population(count, length, min, max):
    """
    Create a number of individuals (i.e. a population).

    count: the number of individuals in the population
    length: the number of values per individual
    min: the minimum possible value in an individual's list of values
    max: the maximum possible value in an individual's list of values

    """
    return [ individual(length, min, max) for x in range(count) ]

def fitness(individual, target):
    """
    Determine the fitness of an individual. Higher is better.

    individual: the individual to evaluate
    target: the target number individuals are aiming for
    """
    error = np.subtract(target, individual)
    #sum = reduce(add, individual, 0)
    return sum(abs(error))

def fitnessMSE(individual, target):
    """
    Determine the fitness of an individual. Higher is better.

    individual: the individual to evaluate
    target: the target number individuals are aiming for
    """

    # Calculate error as difference between each y value prediction and corresponding target
    errors = np.subtract(target, individual)

    # Square each error term
    squaredErrors = np.power(errors, 2)

    # Calculate weighted average of the squared errors array
    meanSquaredErrors = np.average(squaredErrors)

    return meanSquaredErrors

def grade(pop, target):
    """
    Find average fitness for a population.
    :param pop:
    :param target:
    :return:
    """
    summed = sum(fitness(x, target) for x in pop)
    return summed / (len(pop) * 1.0)

def selectRandom(graded, retain, random_select):

    # Begin selection
    graded = [x[1] for x in sorted(graded)]
    retain_length = int(len(graded) * retain)
    parents = graded[:retain_length]
    # randomly add other individuals to
    # promote genetic diversity
    for individual in graded[retain_length:]:
        if random_select > random():
            parents.append(individual)

    return parents

def selectRoulette(graded):

    parents = []

    # Extract error values and individuals
    errors = [x[0] for x in graded]
    individuals = [x[1] for x in graded]

    # Calculate sum of all errors
    sumError = sum(errors)

    # Calculate selection probabilities as fraction of individual's error out of the total errors
    # Raise probabilities to power to increase distinction between good and very good individuals
    probabilities = [(1 - error/sumError)**2 for error in errors]

    # Generate cumulative sum of probabilities so that individuals with least error are most likely to be picked
    probabilitiesCS = np.cumsum(probabilities)

    # Scale probabilities to be within range [0,1]
    scaled = np.divide(probabilitiesCS, max(probabilitiesCS))

    # Select individuals to be added to parent mating pool based on probabilities generated by relative fitness of individual
    for probability, individual in zip(scaled, individuals):
        if probability > uniform(scaled[0], scaled[-1]):
            parents.append(individual)

    return parents

def evolve(pop, target, retain=0.2, random_select=0.05, mutate=0.01, selectMethod='random', errorMethod='abs'):

    if 'mse' in errorMethod:
        graded = [(fitnessMSE(x, target), x) for x in pop]
    elif 'abs' in errorMethod:
        graded = [(fitness(x, target), x) for x in pop]
    else:
        raise NotImplementedError

    if 'random' in selectMethod:
        parents = selectRandom(graded, retain, random_select)
    elif 'roulette' in selectMethod:
        parents = selectRoulette(graded)
    else:
        raise NotImplementedError

    # mutate some individuals
    for individual in parents:
        if mutate > random():
            pos_to_mutate = randint(0, len(individual)-1)
            individual[pos_to_mutate] = randint(min(individual), max(individual))

    # crossover parents to create children
    parents_length = len(parents)
    desired_length = len(pop) - parents_length
    children = []

    while len(children) < desired_length:
        male = randint(0, parents_length-1)
        female = randint(0, parents_length-1)
        if male != female:
            male = parents[male]
            female = parents[female]
            half = int(len(male) / 2)
            child = male[:half] + female[half:]
            children.append(child)
    parents.extend(children)
    return parents